#!/usr/bin/env python3
"""
SME Network Security Assessment Framework
Week 6: Automated Penetration Testing Script

This script automates penetration testing activities including:
- Network scanning with Nmap
- Vulnerability detection
- Safe exploit verification
- Comprehensive report generation

Author: SME Security Team
Version: 1.0.0
"""

import subprocess
import json
import logging
import socket
import ssl
import argparse
import os
import sys
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from concurrent.futures import ThreadPoolExecutor, as_completed
import xml.etree.ElementTree as ET
import re
import hashlib

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('pentest_automation.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


@dataclass
class Finding:
    """Represents a security finding"""
    severity: str  # critical, high, medium, low, info
    category: str
    title: str
    description: str
    affected_host: str
    affected_port: Optional[int] = None
    evidence: str = ""
    remediation: str = ""
    cvss_score: Optional[float] = None
    cve_ids: List[str] = field(default_factory=list)


@dataclass
class ScanResult:
    """Represents scan results for a target"""
    target: str
    scan_time: str
    open_ports: List[Dict[str, Any]] = field(default_factory=list)
    services: List[Dict[str, Any]] = field(default_factory=list)
    vulnerabilities: List[Finding] = field(default_factory=list)
    os_detection: Optional[str] = None


class NmapScanner:
    """Handles Nmap scanning operations"""

    def __init__(self, nmap_path: str = "nmap"):
        self.nmap_path = nmap_path
        self.verify_nmap()

    def verify_nmap(self) -> bool:
        """Verify Nmap is installed and accessible"""
        try:
            result = subprocess.run(
                [self.nmap_path, "--version"],
                capture_output=True,
                text=True,
                timeout=10
            )
            if result.returncode == 0:
                version_match = re.search(r'Nmap version (\d+\.\d+)', result.stdout)
                if version_match:
                    logger.info(f"Nmap version {version_match.group(1)} found")
                return True
        except FileNotFoundError:
            logger.warning("Nmap not found - scan features will be limited")
            return False
        except Exception as e:
            logger.warning(f"Error verifying Nmap: {e}")
            return False
        return False

    def quick_scan(self, target: str) -> ScanResult:
        """Perform a quick scan of top 100 ports"""
        logger.info(f"Starting quick scan of {target}")
        return self._run_scan(target, ["-sV", "-sC", "--top-ports", "100", "-T4"])

    def full_scan(self, target: str) -> ScanResult:
        """Perform a comprehensive scan of all ports"""
        logger.info(f"Starting full scan of {target}")
        return self._run_scan(target, ["-sV", "-sC", "-O", "-p-", "-T4", "--script=vuln"])

    def vulnerability_scan(self, target: str) -> ScanResult:
        """Perform vulnerability-focused scan"""
        logger.info(f"Starting vulnerability scan of {target}")
        scripts = "vuln,exploit,auth,default"
        return self._run_scan(target, ["-sV", "--script", scripts, "-T4"])

    def _run_scan(self, target: str, options: List[str]) -> ScanResult:
        """Execute Nmap scan and parse results"""
        scan_result = ScanResult(
            target=target,
            scan_time=datetime.now().isoformat()
        )

        try:
            # Build command
            cmd = [self.nmap_path] + options + ["-oX", "-", target]

            # Run Nmap
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=1800  # 30 minute timeout
            )

            if result.returncode == 0:
                scan_result = self._parse_nmap_xml(result.stdout, target)
            else:
                logger.error(f"Nmap scan failed: {result.stderr}")

        except subprocess.TimeoutExpired:
            logger.error(f"Scan of {target} timed out")
        except Exception as e:
            logger.error(f"Error scanning {target}: {e}")

        return scan_result

    def _parse_nmap_xml(self, xml_output: str, target: str) -> ScanResult:
        """Parse Nmap XML output"""
        scan_result = ScanResult(
            target=target,
            scan_time=datetime.now().isoformat()
        )

        try:
            root = ET.fromstring(xml_output)

            for host in root.findall('.//host'):
                # Check if host is up
                status = host.find('status')
                if status is not None and status.get('state') != 'up':
                    continue

                # Parse OS detection
                os_elem = host.find('.//osmatch')
                if os_elem is not None:
                    scan_result.os_detection = os_elem.get('name', 'Unknown')

                # Parse ports
                for port in host.findall('.//port'):
                    port_id = int(port.get('portid', 0))
                    protocol = port.get('protocol', 'tcp')

                    state = port.find('state')
                    if state is not None and state.get('state') == 'open':
                        service = port.find('service')
                        service_info = {
                            'port': port_id,
                            'protocol': protocol,
                            'service': service.get('name', 'unknown') if service is not None else 'unknown',
                            'version': service.get('version', '') if service is not None else '',
                            'product': service.get('product', '') if service is not None else ''
                        }

                        scan_result.open_ports.append({
                            'port': port_id,
                            'protocol': protocol,
                            'state': 'open'
                        })
                        scan_result.services.append(service_info)

                        # Parse script output for vulnerabilities
                        for script in port.findall('.//script'):
                            self._parse_script_output(
                                script, scan_result, target, port_id
                            )

        except ET.ParseError as e:
            logger.error(f"Error parsing Nmap XML: {e}")

        return scan_result

    def _parse_script_output(self, script: ET.Element, result: ScanResult,
                             host: str, port: int) -> None:
        """Parse Nmap script output for vulnerabilities"""
        script_id = script.get('id', '')
        output = script.get('output', '')

        # Check for known vulnerability patterns
        vuln_patterns = {
            'ssl-heartbleed': ('critical', 'Heartbleed vulnerability detected'),
            'smb-vuln-ms17-010': ('critical', 'EternalBlue/MS17-010 vulnerability'),
            'ssl-poodle': ('medium', 'POODLE SSL vulnerability'),
            'ssl-dh-params': ('medium', 'Weak Diffie-Hellman parameters'),
            'http-vuln-cve': ('high', 'HTTP vulnerability detected'),
            'ssh-brute': ('medium', 'SSH brute force possible'),
        }

        for pattern, (severity, title) in vuln_patterns.items():
            if pattern in script_id.lower():
                # Extract CVE IDs
                cves = re.findall(r'CVE-\d{4}-\d+', output, re.IGNORECASE)

                finding = Finding(
                    severity=severity,
                    category='Vulnerability',
                    title=title,
                    description=output[:500],
                    affected_host=host,
                    affected_port=port,
                    evidence=output,
                    cve_ids=cves
                )
                result.vulnerabilities.append(finding)


class VulnerabilityChecker:
    """Checks for common vulnerabilities"""

    def __init__(self):
        self.checks = [
            self.check_ssl_tls,
            self.check_http_headers,
            self.check_ssh_config,
            self.check_dns_zone_transfer,
            self.check_smb_signing,
        ]

    def run_all_checks(self, target: str, services: List[Dict]) -> List[Finding]:
        """Run all vulnerability checks against target"""
        findings = []

        for check in self.checks:
            try:
                result = check(target, services)
                if result:
                    findings.extend(result if isinstance(result, list) else [result])
            except Exception as e:
                logger.error(f"Error in check {check.__name__}: {e}")

        return findings

    def check_ssl_tls(self, target: str, services: List[Dict]) -> List[Finding]:
        """Check SSL/TLS configuration"""
        findings = []
        ssl_ports = [s['port'] for s in services if s.get('service') in ['https', 'ssl', 'imaps', 'pop3s']]

        # Also check port 443 if open
        if any(s['port'] == 443 for s in services):
            ssl_ports.append(443)

        ssl_ports = list(set(ssl_ports))

        for port in ssl_ports:
            try:
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE

                with socket.create_connection((target, port), timeout=5) as sock:
                    with context.wrap_socket(sock, server_hostname=target) as ssock:
                        cert = ssock.getpeercert(binary_form=True)
                        protocol = ssock.version()
                        cipher = ssock.cipher()

                        # Check for weak protocols
                        if protocol in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                            findings.append(Finding(
                                severity='high',
                                category='SSL/TLS',
                                title=f'Weak SSL/TLS protocol: {protocol}',
                                description=f'The server supports deprecated {protocol} protocol',
                                affected_host=target,
                                affected_port=port,
                                remediation='Disable SSLv2, SSLv3, TLSv1.0, and TLSv1.1. Enable only TLSv1.2 and TLSv1.3'
                            ))

                        # Check cipher strength
                        if cipher and cipher[2] < 128:
                            findings.append(Finding(
                                severity='medium',
                                category='SSL/TLS',
                                title='Weak cipher suite',
                                description=f'Cipher {cipher[0]} uses only {cipher[2]} bits',
                                affected_host=target,
                                affected_port=port,
                                remediation='Configure server to use strong ciphers (AES-256, ChaCha20)'
                            ))

            except socket.timeout:
                logger.debug(f"SSL check timeout on {target}:{port}")
            except Exception as e:
                logger.debug(f"SSL check error on {target}:{port}: {e}")

        return findings

    def check_http_headers(self, target: str, services: List[Dict]) -> List[Finding]:
        """Check HTTP security headers"""
        findings = []
        http_ports = [s['port'] for s in services if s.get('service') in ['http', 'https']]

        if 80 in [s['port'] for s in services]:
            http_ports.append(80)
        if 443 in [s['port'] for s in services]:
            http_ports.append(443)

        http_ports = list(set(http_ports))

        security_headers = [
            'X-Frame-Options',
            'X-Content-Type-Options',
            'Strict-Transport-Security',
            'Content-Security-Policy',
            'X-XSS-Protection'
        ]

        for port in http_ports:
            try:
                import urllib.request
                import urllib.error

                protocol = 'https' if port == 443 else 'http'
                url = f"{protocol}://{target}:{port}/"

                req = urllib.request.Request(url, headers={'User-Agent': 'SecurityScanner/1.0'})

                # Create SSL context that doesn't verify
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE

                response = urllib.request.urlopen(req, timeout=10, context=ctx)
                headers = dict(response.headers)

                missing_headers = []
                for header in security_headers:
                    if header.lower() not in [h.lower() for h in headers.keys()]:
                        missing_headers.append(header)

                if missing_headers:
                    findings.append(Finding(
                        severity='medium',
                        category='HTTP Headers',
                        title='Missing security headers',
                        description=f'Missing headers: {", ".join(missing_headers)}',
                        affected_host=target,
                        affected_port=port,
                        remediation='Configure web server to include all security headers'
                    ))

            except Exception as e:
                logger.debug(f"HTTP header check error on {target}:{port}: {e}")

        return findings

    def check_ssh_config(self, target: str, services: List[Dict]) -> List[Finding]:
        """Check SSH configuration"""
        findings = []
        ssh_ports = [s['port'] for s in services if s.get('service') == 'ssh']

        if 22 in [s['port'] for s in services]:
            ssh_ports.append(22)

        ssh_ports = list(set(ssh_ports))

        for port in ssh_ports:
            try:
                with socket.create_connection((target, port), timeout=5) as sock:
                    banner = sock.recv(1024).decode('utf-8', errors='ignore')

                    # Check SSH version
                    if 'SSH-1' in banner:
                        findings.append(Finding(
                            severity='critical',
                            category='SSH',
                            title='SSH Protocol 1 enabled',
                            description='Server supports deprecated SSH Protocol 1',
                            affected_host=target,
                            affected_port=port,
                            evidence=banner,
                            remediation='Disable SSH Protocol 1, use only Protocol 2'
                        ))

                    # Check for old versions
                    version_match = re.search(r'OpenSSH[_\s](\d+\.\d+)', banner)
                    if version_match:
                        version = float(version_match.group(1))
                        if version < 7.0:
                            findings.append(Finding(
                                severity='high',
                                category='SSH',
                                title='Outdated OpenSSH version',
                                description=f'OpenSSH version {version} is outdated',
                                affected_host=target,
                                affected_port=port,
                                evidence=banner,
                                remediation='Update OpenSSH to latest version'
                            ))

            except Exception as e:
                logger.debug(f"SSH check error on {target}:{port}: {e}")

        return findings

    def check_dns_zone_transfer(self, target: str, services: List[Dict]) -> List[Finding]:
        """Check for DNS zone transfer vulnerability"""
        findings = []
        dns_ports = [s['port'] for s in services if s.get('service') == 'domain']

        if 53 in [s['port'] for s in services]:
            dns_ports.append(53)

        # DNS zone transfer check would require dnspython or dig
        # Simplified check here
        for port in dns_ports:
            findings.append(Finding(
                severity='info',
                category='DNS',
                title='DNS service detected',
                description='DNS service is running - manual zone transfer check recommended',
                affected_host=target,
                affected_port=port,
                remediation='Ensure zone transfers are restricted to authorized servers only'
            ))

        return findings

    def check_smb_signing(self, target: str, services: List[Dict]) -> List[Finding]:
        """Check SMB signing configuration"""
        findings = []
        smb_ports = [445, 139]

        for port in smb_ports:
            if any(s['port'] == port for s in services):
                findings.append(Finding(
                    severity='info',
                    category='SMB',
                    title='SMB service detected',
                    description='SMB service is running - manual signing check recommended',
                    affected_host=target,
                    affected_port=port,
                    remediation='Enable SMB signing requirement to prevent relay attacks'
                ))

        return findings


class SafeExploitTester:
    """Tests for exploitable conditions safely without causing damage"""

    def __init__(self):
        self.tests = [
            self.test_default_credentials,
            self.test_anonymous_access,
            self.test_directory_listing,
            self.test_common_files,
        ]

    def run_safe_tests(self, target: str, services: List[Dict]) -> List[Finding]:
        """Run safe exploit verification tests"""
        findings = []

        for test in self.tests:
            try:
                result = test(target, services)
                if result:
                    findings.extend(result if isinstance(result, list) else [result])
            except Exception as e:
                logger.error(f"Error in test {test.__name__}: {e}")

        return findings

    def test_default_credentials(self, target: str, services: List[Dict]) -> List[Finding]:
        """Test for default credentials (non-intrusive)"""
        findings = []

        # Check for web login pages
        http_ports = [s['port'] for s in services if s.get('service') in ['http', 'https']]
        http_ports.extend([80, 443, 8080, 8443])
        http_ports = list(set(http_ports))

        common_admin_paths = [
            '/admin', '/login', '/administrator', '/wp-admin',
            '/phpmyadmin', '/manager/html', '/console'
        ]

        for port in http_ports:
            for path in common_admin_paths:
                try:
                    import urllib.request
                    import urllib.error

                    protocol = 'https' if port in [443, 8443] else 'http'
                    url = f"{protocol}://{target}:{port}{path}"

                    ctx = ssl.create_default_context()
                    ctx.check_hostname = False
                    ctx.verify_mode = ssl.CERT_NONE

                    req = urllib.request.Request(url, headers={'User-Agent': 'SecurityScanner/1.0'})
                    response = urllib.request.urlopen(req, timeout=5, context=ctx)

                    if response.status == 200:
                        content = response.read(10000).decode('utf-8', errors='ignore')
                        if any(word in content.lower() for word in ['login', 'password', 'username', 'signin']):
                            findings.append(Finding(
                                severity='info',
                                category='Authentication',
                                title=f'Login page found: {path}',
                                description=f'Administrative login page accessible at {url}',
                                affected_host=target,
                                affected_port=port,
                                remediation='Ensure strong authentication and consider IP whitelisting'
                            ))

                except Exception:
                    pass

        return findings

    def test_anonymous_access(self, target: str, services: List[Dict]) -> List[Finding]:
        """Test for anonymous FTP/SMB access"""
        findings = []

        # Check FTP
        if any(s['port'] == 21 for s in services) or any(s.get('service') == 'ftp' for s in services):
            try:
                import ftplib
                ftp = ftplib.FTP()
                ftp.connect(target, 21, timeout=5)
                ftp.login('anonymous', 'test@test.com')

                findings.append(Finding(
                    severity='high',
                    category='FTP',
                    title='Anonymous FTP access enabled',
                    description='FTP server allows anonymous login',
                    affected_host=target,
                    affected_port=21,
                    remediation='Disable anonymous FTP access unless explicitly required'
                ))

                # Check if we can write
                try:
                    ftp.mkd('test_write_check')
                    ftp.rmd('test_write_check')
                    findings.append(Finding(
                        severity='critical',
                        category='FTP',
                        title='Anonymous FTP write access',
                        description='Anonymous user can write to FTP server',
                        affected_host=target,
                        affected_port=21,
                        remediation='Remove anonymous write permissions immediately'
                    ))
                except:
                    pass

                ftp.quit()
            except Exception:
                pass

        return findings

    def test_directory_listing(self, target: str, services: List[Dict]) -> List[Finding]:
        """Test for directory listing enabled"""
        findings = []
        http_ports = [s['port'] for s in services if s.get('service') in ['http', 'https']]
        http_ports.extend([80, 443])
        http_ports = list(set(http_ports))

        test_dirs = ['/', '/images/', '/css/', '/js/', '/uploads/', '/backup/']

        for port in http_ports:
            for dir_path in test_dirs:
                try:
                    import urllib.request

                    protocol = 'https' if port == 443 else 'http'
                    url = f"{protocol}://{target}:{port}{dir_path}"

                    ctx = ssl.create_default_context()
                    ctx.check_hostname = False
                    ctx.verify_mode = ssl.CERT_NONE

                    req = urllib.request.Request(url, headers={'User-Agent': 'SecurityScanner/1.0'})
                    response = urllib.request.urlopen(req, timeout=5, context=ctx)

                    if response.status == 200:
                        content = response.read(5000).decode('utf-8', errors='ignore')
                        if '<title>Index of' in content or 'Parent Directory' in content:
                            findings.append(Finding(
                                severity='medium',
                                category='Web Server',
                                title=f'Directory listing enabled: {dir_path}',
                                description=f'Directory listing is enabled at {url}',
                                affected_host=target,
                                affected_port=port,
                                remediation='Disable directory listing in web server configuration'
                            ))
                            break  # One finding per port is enough

                except Exception:
                    pass

        return findings

    def test_common_files(self, target: str, services: List[Dict]) -> List[Finding]:
        """Test for common sensitive files"""
        findings = []
        http_ports = [s['port'] for s in services if s.get('service') in ['http', 'https']]
        http_ports.extend([80, 443])
        http_ports = list(set(http_ports))

        sensitive_files = [
            '/robots.txt', '/.git/HEAD', '/.env', '/wp-config.php.bak',
            '/phpinfo.php', '/server-status', '/web.config', '/.htaccess'
        ]

        for port in http_ports:
            for file_path in sensitive_files:
                try:
                    import urllib.request

                    protocol = 'https' if port == 443 else 'http'
                    url = f"{protocol}://{target}:{port}{file_path}"

                    ctx = ssl.create_default_context()
                    ctx.check_hostname = False
                    ctx.verify_mode = ssl.CERT_NONE

                    req = urllib.request.Request(url, headers={'User-Agent': 'SecurityScanner/1.0'})
                    response = urllib.request.urlopen(req, timeout=5, context=ctx)

                    if response.status == 200:
                        severity = 'high' if file_path in ['/.git/HEAD', '/.env', '/wp-config.php.bak'] else 'info'
                        findings.append(Finding(
                            severity=severity,
                            category='Information Disclosure',
                            title=f'Sensitive file accessible: {file_path}',
                            description=f'Potentially sensitive file found at {url}',
                            affected_host=target,
                            affected_port=port,
                            remediation='Remove or restrict access to sensitive files'
                        ))

                except Exception:
                    pass

        return findings


class PentestReportGenerator:
    """Generates penetration test reports"""

    def __init__(self, output_dir: str = "reports"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_report(self, scan_results: List[ScanResult],
                       all_findings: List[Finding]) -> Dict[str, str]:
        """Generate reports in multiple formats"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        reports = {}

        # Generate JSON report
        json_path = self.output_dir / f"pentest_report_{timestamp}.json"
        reports['json'] = str(json_path)
        self._generate_json_report(scan_results, all_findings, json_path)

        # Generate HTML report
        html_path = self.output_dir / f"pentest_report_{timestamp}.html"
        reports['html'] = str(html_path)
        self._generate_html_report(scan_results, all_findings, html_path)

        # Generate executive summary
        summary_path = self.output_dir / f"executive_summary_{timestamp}.txt"
        reports['summary'] = str(summary_path)
        self._generate_executive_summary(scan_results, all_findings, summary_path)

        return reports

    def _generate_json_report(self, scan_results: List[ScanResult],
                             findings: List[Finding], path: Path) -> None:
        """Generate JSON report"""
        report_data = {
            'report_metadata': {
                'title': 'SME Network Security Assessment - Penetration Test Report',
                'generated': datetime.now().isoformat(),
                'framework_version': '1.0.0'
            },
            'executive_summary': {
                'total_targets': len(scan_results),
                'total_findings': len(findings),
                'critical': len([f for f in findings if f.severity == 'critical']),
                'high': len([f for f in findings if f.severity == 'high']),
                'medium': len([f for f in findings if f.severity == 'medium']),
                'low': len([f for f in findings if f.severity == 'low']),
                'info': len([f for f in findings if f.severity == 'info'])
            },
            'scan_results': [asdict(r) for r in scan_results],
            'findings': [asdict(f) for f in findings]
        }

        with open(path, 'w') as f:
            json.dump(report_data, f, indent=2, default=str)

        logger.info(f"JSON report saved to {path}")

    def _generate_html_report(self, scan_results: List[ScanResult],
                             findings: List[Finding], path: Path) -> None:
        """Generate HTML report"""
        severity_colors = {
            'critical': '#dc3545',
            'high': '#fd7e14',
            'medium': '#ffc107',
            'low': '#17a2b8',
            'info': '#6c757d'
        }

        html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penetration Test Report</title>
    <style>
        body {{ font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        h1 {{ color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }}
        h2 {{ color: #34495e; margin-top: 30px; }}
        .summary-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0; }}
        .summary-card {{ padding: 20px; border-radius: 8px; text-align: center; color: white; }}
        .summary-card h3 {{ margin: 0; font-size: 2em; }}
        .summary-card p {{ margin: 5px 0 0 0; }}
        .finding {{ border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 15px 0; border-left: 4px solid; }}
        .finding-critical {{ border-left-color: #dc3545; }}
        .finding-high {{ border-left-color: #fd7e14; }}
        .finding-medium {{ border-left-color: #ffc107; }}
        .finding-low {{ border-left-color: #17a2b8; }}
        .finding-info {{ border-left-color: #6c757d; }}
        .severity-badge {{ display: inline-block; padding: 3px 10px; border-radius: 4px; color: white; font-size: 0.85em; font-weight: bold; }}
        .host-section {{ background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0; }}
        table {{ width: 100%; border-collapse: collapse; margin: 10px 0; }}
        th, td {{ padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background: #3498db; color: white; }}
        tr:hover {{ background: #f5f5f5; }}
        .remediation {{ background: #e8f5e9; padding: 10px; border-radius: 4px; margin-top: 10px; }}
        .footer {{ margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 0.9em; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>SME Network Security Assessment</h1>
        <h2>Penetration Test Report</h2>
        <p><strong>Generated:</strong> {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>

        <h2>Executive Summary</h2>
        <div class="summary-grid">
            <div class="summary-card" style="background: #dc3545;">
                <h3>{len([f for f in findings if f.severity == 'critical'])}</h3>
                <p>Critical</p>
            </div>
            <div class="summary-card" style="background: #fd7e14;">
                <h3>{len([f for f in findings if f.severity == 'high'])}</h3>
                <p>High</p>
            </div>
            <div class="summary-card" style="background: #ffc107; color: #333;">
                <h3>{len([f for f in findings if f.severity == 'medium'])}</h3>
                <p>Medium</p>
            </div>
            <div class="summary-card" style="background: #17a2b8;">
                <h3>{len([f for f in findings if f.severity == 'low'])}</h3>
                <p>Low</p>
            </div>
            <div class="summary-card" style="background: #6c757d;">
                <h3>{len([f for f in findings if f.severity == 'info'])}</h3>
                <p>Informational</p>
            </div>
        </div>

        <h2>Scan Results by Host</h2>
"""

        for result in scan_results:
            html_content += f"""
        <div class="host-section">
            <h3>Target: {result.target}</h3>
            <p><strong>Scan Time:</strong> {result.scan_time}</p>
            <p><strong>OS Detection:</strong> {result.os_detection or 'Unknown'}</p>

            <h4>Open Ports ({len(result.open_ports)})</h4>
            <table>
                <tr><th>Port</th><th>Protocol</th><th>Service</th><th>Version</th></tr>
"""
            for svc in result.services:
                html_content += f"<tr><td>{svc['port']}</td><td>{svc['protocol']}</td><td>{svc['service']}</td><td>{svc.get('version', '')}</td></tr>\n"

            html_content += "</table></div>\n"

        html_content += "<h2>Detailed Findings</h2>\n"

        # Sort findings by severity
        severity_order = ['critical', 'high', 'medium', 'low', 'info']
        sorted_findings = sorted(findings, key=lambda f: severity_order.index(f.severity))

        for finding in sorted_findings:
            html_content += f"""
        <div class="finding finding-{finding.severity}">
            <span class="severity-badge" style="background: {severity_colors[finding.severity]};">{finding.severity.upper()}</span>
            <h4>{finding.title}</h4>
            <p><strong>Category:</strong> {finding.category}</p>
            <p><strong>Affected:</strong> {finding.affected_host}:{finding.affected_port or 'N/A'}</p>
            <p><strong>Description:</strong> {finding.description}</p>
            {f'<p><strong>CVEs:</strong> {", ".join(finding.cve_ids)}</p>' if finding.cve_ids else ''}
            {f'<div class="remediation"><strong>Remediation:</strong> {finding.remediation}</div>' if finding.remediation else ''}
        </div>
"""

        html_content += f"""
        <div class="footer">
            <p>This report was generated by the SME Network Security Assessment Framework v1.0.0</p>
            <p>Report generated on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
        </div>
    </div>
</body>
</html>
"""

        with open(path, 'w', encoding='utf-8') as f:
            f.write(html_content)

        logger.info(f"HTML report saved to {path}")

    def _generate_executive_summary(self, scan_results: List[ScanResult],
                                   findings: List[Finding], path: Path) -> None:
        """Generate executive summary"""
        critical = len([f for f in findings if f.severity == 'critical'])
        high = len([f for f in findings if f.severity == 'high'])
        medium = len([f for f in findings if f.severity == 'medium'])
        low = len([f for f in findings if f.severity == 'low'])
        info = len([f for f in findings if f.severity == 'info'])

        # Calculate risk score (weighted)
        risk_score = (critical * 10 + high * 5 + medium * 2 + low * 0.5) / max(len(findings), 1) * 10
        risk_score = min(100, risk_score)

        risk_level = 'LOW'
        if risk_score > 70:
            risk_level = 'CRITICAL'
        elif risk_score > 50:
            risk_level = 'HIGH'
        elif risk_score > 30:
            risk_level = 'MEDIUM'

        summary = f"""
================================================================================
                    SME NETWORK SECURITY ASSESSMENT
                      PENETRATION TEST - EXECUTIVE SUMMARY
================================================================================

Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

OVERALL RISK ASSESSMENT
-----------------------
Risk Score: {risk_score:.1f}/100
Risk Level: {risk_level}

FINDINGS SUMMARY
----------------
Critical Findings:     {critical:>4}
High Findings:         {high:>4}
Medium Findings:       {medium:>4}
Low Findings:          {low:>4}
Informational:         {info:>4}
                       ----
Total Findings:        {len(findings):>4}

TARGETS ASSESSED
----------------
Total Targets: {len(scan_results)}
Total Open Ports: {sum(len(r.open_ports) for r in scan_results)}

KEY FINDINGS REQUIRING IMMEDIATE ATTENTION
------------------------------------------
"""
        # Add critical and high findings
        urgent = [f for f in findings if f.severity in ['critical', 'high']]
        for i, finding in enumerate(urgent[:5], 1):
            summary += f"""
{i}. [{finding.severity.upper()}] {finding.title}
   Host: {finding.affected_host}:{finding.affected_port or 'N/A'}
   {finding.description[:200]}
"""

        summary += f"""

RECOMMENDATIONS
---------------
1. Address all critical findings within 24-48 hours
2. Remediate high-severity issues within 1 week
3. Plan medium-severity remediation within 30 days
4. Review and prioritize low-severity findings
5. Consider implementing additional security controls

================================================================================
                           END OF EXECUTIVE SUMMARY
================================================================================
"""

        with open(path, 'w') as f:
            f.write(summary)

        logger.info(f"Executive summary saved to {path}")


class PentestAutomation:
    """Main class for automated penetration testing"""

    def __init__(self, config: Optional[Dict] = None):
        self.config = config or {}
        self.scanner = NmapScanner()
        self.vuln_checker = VulnerabilityChecker()
        self.exploit_tester = SafeExploitTester()
        self.report_generator = PentestReportGenerator()
        self.scan_results: List[ScanResult] = []
        self.all_findings: List[Finding] = []

    def run_assessment(self, targets: List[str], scan_type: str = "full") -> Dict:
        """Run complete penetration test assessment"""
        logger.info(f"Starting penetration test on {len(targets)} targets")
        start_time = datetime.now()

        # Phase 1: Network Scanning
        logger.info("=== Phase 1: Network Scanning ===")
        for target in targets:
            if scan_type == "quick":
                result = self.scanner.quick_scan(target)
            elif scan_type == "vuln":
                result = self.scanner.vulnerability_scan(target)
            else:
                result = self.scanner.full_scan(target)

            self.scan_results.append(result)
            self.all_findings.extend(result.vulnerabilities)

        # Phase 2: Vulnerability Checking
        logger.info("=== Phase 2: Vulnerability Analysis ===")
        for result in self.scan_results:
            findings = self.vuln_checker.run_all_checks(result.target, result.services)
            self.all_findings.extend(findings)

        # Phase 3: Safe Exploit Testing
        logger.info("=== Phase 3: Exploit Verification ===")
        for result in self.scan_results:
            findings = self.exploit_tester.run_safe_tests(result.target, result.services)
            self.all_findings.extend(findings)

        # Phase 4: Report Generation
        logger.info("=== Phase 4: Report Generation ===")
        reports = self.report_generator.generate_report(self.scan_results, self.all_findings)

        # Calculate statistics
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()

        summary = {
            'assessment_completed': True,
            'targets_scanned': len(targets),
            'duration_seconds': duration,
            'total_findings': len(self.all_findings),
            'findings_by_severity': {
                'critical': len([f for f in self.all_findings if f.severity == 'critical']),
                'high': len([f for f in self.all_findings if f.severity == 'high']),
                'medium': len([f for f in self.all_findings if f.severity == 'medium']),
                'low': len([f for f in self.all_findings if f.severity == 'low']),
                'info': len([f for f in self.all_findings if f.severity == 'info'])
            },
            'reports': reports
        }

        logger.info(f"Assessment completed in {duration:.2f} seconds")
        logger.info(f"Total findings: {len(self.all_findings)}")

        return summary


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='SME Network Security Assessment - Automated Penetration Testing'
    )
    parser.add_argument(
        'targets',
        nargs='+',
        help='Target IP addresses or hostnames to scan'
    )
    parser.add_argument(
        '-t', '--type',
        choices=['quick', 'full', 'vuln'],
        default='full',
        help='Scan type: quick (top 100 ports), full (all ports), vuln (vulnerability focused)'
    )
    parser.add_argument(
        '-o', '--output',
        default='reports',
        help='Output directory for reports'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )

    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Initialize and run
    pentest = PentestAutomation()
    pentest.report_generator.output_dir = Path(args.output)
    pentest.report_generator.output_dir.mkdir(parents=True, exist_ok=True)

    try:
        results = pentest.run_assessment(args.targets, args.type)

        print("\n" + "=" * 60)
        print("PENETRATION TEST COMPLETED")
        print("=" * 60)
        print(f"Targets scanned: {results['targets_scanned']}")
        print(f"Duration: {results['duration_seconds']:.2f} seconds")
        print(f"\nFindings Summary:")
        for severity, count in results['findings_by_severity'].items():
            print(f"  {severity.capitalize()}: {count}")
        print(f"\nReports generated:")
        for report_type, path in results['reports'].items():
            print(f"  {report_type}: {path}")

    except KeyboardInterrupt:
        print("\n\nAssessment interrupted by user")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Assessment failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
